# Proposal: Update Workflow Server Interface

Currently (as of version 1.15), ad-hoc runtime interaction with Temporal
workflows is achieved through queries and signals. The former technique can
interrogate the state of a workflow and returns a result but must not _change_
the state of the workflow, while the latter can change workflow state but does
not natively support return values [^1]. 

The missing piece in runtime workflow interaction is an affordance that
provides both (1) the ability to change workflow state, and (2) a mechanism to
observe the result of the same without polling or setting up callback
structures. This feature will be workflow updates.

This proposal describes the server API (i.e. gRPC) for such a feature. We leave
implementation details for a deeper design review and instead relate the API,
its expected usage and the guarantees provided.

## Concepts

### Update

An Update is the execution of arbitrary workflow logic (subject to the standard
workflow code constraints on determinism) triggered by an UpdateRequest and
eventually resulting in a single UpdateResponse. The processing of an Update is
performed by workflow code and as such the timeliness of the UpdateResponse is
dependent on worker resources being available to process the Update. A given
Update applies to exactly one workflow execution. The lifetime of an Update
begins when the workflow validates an UpdateRequest triggering said Update and
ends when the UpdateResponse has been made durable. Consequently, the lifetime
of an Update may exceed the lifetime of the RPC request/response that initiates
it.

### Update ID

The unique identifier of an Update. Generated by the Temporal server.

### UpdateRequest

An UpdateRequest is a remote call originating either from outside the Temporal
system entirely or from another Temporal workflow.  UpdateRequests are
deduplicated such that issuance of the same UpdateRequest multiple times is
effectively the same as issuing a single request. The UpdateRequest includes an
indication of the workflow execution at which the Update is targeted.
UpdateRequests are issued over gRPC or through SDK-specific APIs wrapping the
same. Both issuing and receiving UpdateRequests becomes a durable part of a
given workflow's history.

### UpdateResponse

The output value of an Update. The UpdateResponse may lack a data playload, in
which case the UpdateResponse only indicates the success or failure of the
Update operation. The UpdateResponse is accessed via gRPC or SDK-specific APIs
wrapping the same. UpdateResponses become durable parts of a given workflow's
history (note that an UpdateResponse depends on the existence of an Update and
the Update depends on the workflow's acceptance of an UpdateRequest, so we can
safely say that UpdateResponses only exist for UpdateRequests that are
accepted). UpdateResponses can be accessed after the lifecycle of the Update has
completed, subject to workflow retention.

## Use Cases

### Short Update

It may be that it is known a priori that an update is expected to execute in an
amount of time that is reasonable for an RPC request/response interaction. In
such cases the issuer may want to block the issuing thread of execution for the
full duration of the update.

### Uncertain Duration Update

It may be the case that there is no expectation on how long an update may take
or the duration may be inherently variable. In such cases the client may want to
block for _up to_ a client-chosen duration after which time the issuing client
disconnects from the RPC but the update processing continues on. The system must
support the client re-attaching to the Update at some point in the future in
order to observe the UpdateResponse. Note that this is different than putting a
timeout on the RPC itself.

### Known Long Update

Similar to the uncertain duration, it may be know a priori that the update will
take more time than the issuer is willing to block the thread of execution
invoking the update. In such cases the update issuer would prefer to not wait at
all for the UpdateResponse, preferring instead to poll for it later.

### Invalid Update

UpdateRequests can be invalid given the state of the receiving workflow. In such
cases the UpdateResponse will contain an error indication and payload. Invalid
updates _must not_ be recorded in workflow history to prevent a byzantine client
from causing a denial of service on the workflow by issuing repeated invalid
UpdateRequests.

### "Failing" Update

UpdateRequests can be semantically acceptable but still fail due to external
dependencies. In such cases the UpdateResponse will contain an error indication
and payload.

### Unexpected Disconnect

While the issuer of an update may wish to block on an UpdateResponse, network
conditions or software failures may occur which forcibly disconnects the update
issuer from the server at the time that the Update completes _and_ before the
issuer becomes aware of the Update ID. The issuer must be able to re-issue the
same UpdateRequest to access the server-generated Update ID.

## gRPC API

The gRPC API comprises two functions, `UpdateWorkflow` and
`PollUpdateWorkflowResponse` to be added to the `WorkflowService` service
definition. The former is used to invoke an update and follows the standard
patterns for identifying a workflow execution and carrying arbitrary metadata
(Header) and payloads (Payloads). The request type for this function includes a
`result_access_style` property indicating whether the caller intends to poll for
a result later (via `PollUpdateWorkflowResponse`) or wants the result to be
delivered "inline" as part of the `UpdateWorkflowResponse` that is returned from
the `UpdateWorkflow` gRPC call. In the case where the client intends to poll,
the RPC will return as soon as the UpdateID is generated (in such cases, the
`UpdateWorkflowResponse` may contain the actual UpdateResponse data or may be
empty with the `UPDATE_WORKFLOW_RESULT_TYPE` flag set to
`UPDATE_WORKFLOW_RESULT_TYPE_IN_PROGRESS`. If the client wants an inline response value,
the RPC will block until the response value (or error) is available or the gRPC
timeout is hit. In either case, the gRPC timeout for this call is server-side
capped at low value, indicating the intent that this call either complete
quickly or at least be validated quickly and the client will switch to polling.
The `request_id` property uniquely identifies the logical request (_not_ the
issuance of the request) and is intended for use as an idempotency token.

As `UpdateWorkflow` executes workflow code in all cases it is recommended that
this function be excluded from rpc latency metrics aggregation.

The second function, `PollUpdateWorkflowResponse` is used when a client has
already issued an `UpdateWorkflow` request and has the resulting `update_id`.
That `update_id` can be provided to re-attach to an in-flight or completed
Update and obtain the associated UpdateResult in the form of an
`UpdateWorkflowResponse`.


```protobuf
service WorkflowService {
    rpc UpdateWorkflow(UpdateWorkflowRequest) returns (UpdateWorkflowResponse){}
    rpc PollUpdateWorkflowResponse(PollUpdateWorkflowResponseRequest) returns (UpdateWorkflowResponse){}
}

message UpdateWorkflowRequest {
    temporal.api.common.v1.Header header = 1;
    string request_id = 2;
    string namespace = 3;
    temporal.api.common.v1.WorkflowExecution execution = 4;
    string first_execution_run_id = 5;
    string update_name = 6;
    temporal.api.common.v1.Payloads input = 7;
    UpdateWorkflowResultAccessStyle result_access_style = 8;
}

message UpdateWorkflowResponse {
    bytes update_id = 1;
    UpdateWorkflowResultType result_type = 2;
    UpdateWorkflowSuccess succeded = 3;
    UpdateWorkflowFailure failed = 4;
}

enum UpdateWorkflowResultAccessStyle {
    UPDATE_WORKFLOW_RESULT_ACCESS_STYLE_UNSPECIFIED = 0;
    UPDATE_WORKFLOW_RESULT_ACCESS_STYLE_INLINE = 1;
    UPDATE_WORKFLOW_RESULT_ACCESS_STYLE_POLL = 2;
}

enum UpdateWorkflowResultType {
    UPDATE_WORKFLOW_RESULT_TYPE_UNSPECIFIED = 0;
    UPDATE_WORKFLOW_RESULT_TYPE_IN_PROGRESS = 1;
    UPDATE_WORKFLOW_RESULT_TYPE_SUCCESS = 2;
    UPDATE_WORKFLOW_RESULT_TYPE_FAILURE = 3;
}

message PollUpdateResponseRequest {
    string namespace_id = 1;
    string workflow_id = 2;
    bytes update_id = 3;
}

message UpdateWorkflowSuccess {
  temporal.api.common.v1.Payloads output = 1;
}

message UpdateWorkflowFailure {
  temporal.api.common.v1.Failure failure = 1;
}
```

## Revisiting Use Cases With Propsed API

### Short Update

Client calls `UpdateWorkflow` with `UpdateWorkflowRequest.result_access_style`
set to `UPDATE_WORKFLOW_RESULT_ACCESS_STYLE_INLINE`. The UpdateResponse is returned
as part of the gRPC response.

### Uncertain Duration Update

Two options:

1. Client calls `UpdateWorkflow` with `UpdateWorkflowRequest.result_access_style`
   set to `UPDATE_WORKFLOW_RESULT_ACCESS_STYLE_INLINE`. If the UpdateResponse is
   slow, client can retry safely with the same `request_id`.
2. Client follows the steps for the "Known Long Update" use case.

### Known Long Update

Client calls `UpdateWorkflow` with `UpdateWorkflowRequest.result_access_style`
set to `UPDATE_WORKFLOW_RESULT_ACCESS_STYLE_POLL`. An UpdateID is returned as
part of the gRPC respons and if that same gRPC response indicates that the
Update is still in progress (i.e. `UpdateWorkflowResponse.result_type ==
UPDATE_WORKFLOW_RESPONSE_TYPE_IN_PROGRESS`), the client can then use
`PollUpdateWorkflowResponse` to wait for Update completion.

### Invalid Update

If the UpdateRequest is rejected by the workflow execution while the RPC client
is still connected, a suitable gRPC error can be returned synchronously. Note
however rejected UpdateRequests are _not_ recorded in workflow history.

### "Failing" Update

An Update that is passes verification by the workflow code and runs to
completion but encounters an error at the application level is still considered
to have completed correctly from the perspective of the Temporal system. The
application-level error is recorded as the `UpdateWorkflowResponse.failure` and
the `UpdateWorkflowResponse.result_type` is set to `UPDATE_RESULT_TYPE_ERROR`.

### Unexpected Disconnect

When a client is waiting on an UpdateResponse having invoked the
`UpdateWorkflow` and it loses connectivity prior to receiving an `update_id`, it
can reissue the same RPC request with the exact same `request_id`. The second
request will either be new to the server (if the first request never made it
there) or will be de-duplicated on the server-side such that the client gets
attached to the execution of the previously submitted request. In either case,
the `UpdateWorkflow` RPC call proceeds and returns normally from the client's
perspective.


## Concurrent Semantics

Update processing both within a single workflow execution and across multiple
workflow executions can procede in parallel however at most one update will be
processed by any single workflow execution at a time. Updates that overlap in
wall-clock time are unordered. Updates based on an UpdateRequest transmitted
after a given UpdateResponse is received are guaranteed to see the changes from
the earlier Update.


[^1]: [Techniques](https://github.com/temporalio/samples-go/tree/main/reqrespactivity)
      have been developed to work around this limitation but they come with their own
      drawbacks in terms of overhead and complexity.
