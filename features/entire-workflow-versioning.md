# Entire Workflow Versioning

### Problem statement

The current method of versioning Workflows is complex and error prone.
By default, there's a good chance that upgrading a worker will result in workflows being stuck due to non-determinism errors.
Recovering from this situation is not trivial because a user now has histories generated by mulitple versions.

### Proposal

Entire Workflow versioning is an approach that'll greatly simplify the current Workflow versioning situation.

- We add a concept of a central repository for Workflow code
- Users deploy their Workflows directly to the central repository
- When a worker encounters the first Workflow Task in history it decides which Workflow code it needs to run
  - New Workflows always use the "latest" version
  - Workflows that were started with an old code version use that same version by default (unless there's an existing patch version (more on that below))

### How does it work?

- In JavaScript (and probably WASM in the future) we bundle the Workflow code with its dependencies into a single file
- In Java we may use Jars (pending POC)
- A user uploads their bundle to a central repository stating whether it's the "latest" version or if it patches an older version

  - Patching requires use of the [`patch`](https://docs.temporal.io/docs/typescript/patching#typescript-sdk-patching-api) marker
    - side-effect: No need for `deprecatePatch` in most cases
  - Example of a version graph (tag versions denote patches)

  [![Version graph](https://mermaid.ink/img/eyJjb2RlIjoiZmxvd2NoYXJ0IExSXG4gICAgVjEgLS0-IFYyIC0tPiBWM1xuICAgIFYxIC0tPiBWMScgLS0-IFYxJydcbiAgICBWMiAtLT4gVjInIC0tPiBWMicnXG5cbiAgICBzdWJncmFwaCBsYXRlc3RcbiAgICAgICAgVjNcbiAgICBlbmQiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOnRydWUsImF1dG9TeW5jIjp0cnVlLCJ1cGRhdGVEaWFncmFtIjp0cnVlfQ)](https://mermaid-js.github.io/mermaid-live-editor/edit/#eyJjb2RlIjoiZmxvd2NoYXJ0IExSXG4gICAgVjEgLS0-IFYyIC0tPiBWM1xuICAgIFYxIC0tPiBWMScgLS0-IFYxJydcbiAgICBWMiAtLT4gVjInIC0tPiBWMicnXG5cbiAgICBzdWJncmFwaCBsYXRlc3RcbiAgICAgICAgVjNcbiAgICBlbmQiLCJtZXJtYWlkIjoie1xuICBcInRoZW1lXCI6IFwiZGVmYXVsdFwiXG59IiwidXBkYXRlRWRpdG9yIjp0cnVlLCJhdXRvU3luYyI6dHJ1ZSwidXBkYXRlRGlhZ3JhbSI6dHJ1ZX0)

- When processing the first Workflow Task, the SDK inserts a version marker to record which code version was used to process this workflow history.

### The repository

(Requires further thought)

- The repository could be part of the Temporal default server deployment although it may very well be an external component
  - It'd probably be the most convenient if our frontends could proxy requests to the repository
- If we put the code in Temporal server we'd need to support encryption
- Having the Workflow code available opens up new options for UI that are not possible today

### How companies handle this today (our recommendation)

Some companies have complex worker deployments where each worker version listen on a separate task queue instead of updating their workers.

For this to work, they set up:

- Autoscaling for each deployment
- A routing layer for clients
- Some way to determine when old workers can be completely removed

#### Comparison of existing recommendation vs. new versioning scheme

##### Pros (for new proposal)

- No need for user to keep old workers around
- Better out of the box experience
- Simplifies versioning for the majority of the userbase
- Activities on old workers may become outdated

##### Cons

- Activities may be removed or upgraded and become incompatible with older Workflows
  - Could we "bundle" those too?
  - Document best practices for maintaining backwards compatibility
  - Provide tools to verify compatibility
- Workers may be upgraded and break state machines compatibility (solvable)
- Deployment / tagging step
