# Workflow versioning 2.0

This proposal introduces two key changes to what is called `getVersion` in the existing SDKs, but will likely be renamed in subsequent ones (more on naming later). The key changes are:

* Introduce a different API for versioning that does not involve a version range, but instead simply returns a boolean indicating if a named change has happened or not. Ex: `hasChange("change-id")`. TBD if we would eliminate the range-based API, or leave it for advanced users.
* It will no longer be valid to replay a workflow history containing a version marker against code which does not have a corresponding call to the version API.

## Boolean-only API and Renaming
The existing `getVersion` API is confusing to users. What's a default version? What should the maximum be? Why is it always returned by workflows that have hit that line for the first time?

If it's the case that very few users ever actually need version ranges, which seems likely, then a much simpler API can be presented. In fact, it's still possible to conceptually represent version ranges with it as well, if needed.

Instead of `get_version("change-id", minver, maxver) -> number`, consider: `changed("change-id") -> bool`

If the workflow code is executing for the first time, it will write a marker into history meaning "change change-id happened". If it is replaying history, it will verify such a marker exists and return true. If the marker does not exist, it will return false. Versions of the code without the call will fail (more on that in other section).

Version ranges can still be simulated if needed like:
```rust
if changed("change-ver-1") {
    // blah
} else if changed("change-ver-2") {
    // blah
}
// etc
```

This seems dramatically more understandable at the cost of making a probably not very common scenario mildly more verbose.

## Enforcing the presence of version API calls/commands in the presence of version markers (2-phase deprecation)
To expand on why the second change is important. Imagine the below two versions of the same (imaginary, Rust) workflow code:

```rust
// Original version
fn workflow() {
   // ...previous code....
   activity_a().await;
   activity_must_run_after_a().await;
}
```

```rust
// Version 2
fn workflow() {
   // ...previous code....
   if changed("change_id") {
       activity_b().await;
   } else {
       activity_a().await;
       activity_must_run_after_a().await;
   }
}
```

Imagine that a run of the workflow begins executing on a worker with version 2. It hits the `get_version` call and writes the marker, and then dies. Then, a worker running the original code picks up that history. It will execute the `a` activities, but it should not have, it was already known that this workflow history should take path B.

With this change, the workflow task would fail because the worker's code does not have a `get_version` call, but there was a version marker in the history.

This has the effect that users now must take a 2-phase approach to deprecating old code, but in exchange are given better guarantees around workflow state consistency. If the user wants to remove path A, they can change their code to:

```rust
// Version 3
fn workflow() {
   // ...previous code....
   must_have_change("change_id")
   activity_b().await;
}
```

The above code can now fail properly if it encounters any histories which lack the version marker (were run by the old code), while still allowing the user to eliminate the old code. This new code does not write a marker if it is creating this part of history for the first time, rather than replaying.

This means the user cannot deploy this "phase 2" code until they know there are no more workers out there running the original code (as, if such a worker were to encounter a history generated by this latest code, it would not see any marker and proceed). Hence, it is important to provide a way for users to query workers so they can know this (apparently, already exists with enhanced visibility?). After no more workflow runs exist which still contain the marker, the `must_have_change` call may be removed entirely.
